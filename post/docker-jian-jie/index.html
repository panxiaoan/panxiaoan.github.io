<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Docker：简介 01 | 行走在年轮之上</title>
<meta name="description" content="她就像蒲公英一样的淘气,不,比蒲公英还要淘气。 有许多人多认为她很笨,可是她总觉得自己是最聪明的。 ">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://panxiaoan.github.io/favicon.ico?v=1559270979810">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://panxiaoan.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://panxiaoan.github.io">
        <img src="https://panxiaoan.github.io/images/avatar.png?v=1559270979810" class="site-logo">
        <h1 class="site-title">行走在年轮之上</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/panxiaoan" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
          <a class="social-link" href="https://www.zhihu.com/people/panningbo/activities" target="_blank">
            <i class="fab fa-zhihu"></i>
          </a>
        
      
        
      
    </div>
    <div class="site-description">
      她就像蒲公英一样的淘气,不,比蒲公英还要淘气。 有许多人多认为她很笨,可是她总觉得自己是最聪明的。 
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/panxiaoan" target="_blank">潘小安</a> | <a class="rss" href="https://panxiaoan.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Docker：简介 01</h2>
            <div class="post-date">2019-05-31</div>
            
            <div class="post-content">
              <h1 id="什么是-docker">什么是 Docker</h1>
<ul>
<li>Docker 使用 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</li>
<li>由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</li>
<li>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极 大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</li>
<li>Docker 支持在 Linux、MacOS、Windows 上安装使用</li>
<li>Docker 官网：<a href="https://www.docker.com/">https://www.docker.com</a></li>
<li>Docker GitHub：<a href="https://github.com/docker/docker-ce">https://github.com/docker/docker-ce</a></li>
<li>Docker Hub（公共镜像库）: <a href="https://hub.docker.com/">https://hub.docker.com</a>，https://registry.docker-cn.com
<ul>
<li>注册账号时，由于验证机制使用了 Google 服务，所以需要翻墙才能注册</li>
</ul>
</li>
</ul>
<h1 id="为什么要使用-docker">为什么要使用 Docker</h1>
<p>作为一种新兴虚拟化方式，Docker 跟传统虚拟化方式相比具有众多优势。</p>
<ul>
<li>
<p><strong>更高效的利用系统资源</strong></p>
<ul>
<li>Docker 容器不需要进行硬件虚拟，以及运行完整操作系统等额外开销，所以 Docker 对系统资源利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的 Docker 容器。</li>
</ul>
</li>
<li>
<p><strong>更快速的启动时间</strong></p>
<ul>
<li>传统虚拟机技术启动往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级启动时间。大大的节约 了开发、测试、部署时间。</li>
</ul>
</li>
<li>
<p><strong>一致的运行环境</strong></p>
<ul>
<li>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</li>
</ul>
</li>
<li>
<p><strong>持续交付和部署</strong></p>
<ul>
<li>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</li>
<li>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成系统进行集成测试， 而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。</li>
<li>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</li>
</ul>
</li>
<li>
<p><strong>更轻松的迁移</strong></p>
<ul>
<li>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台 上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。 因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</li>
</ul>
</li>
<li>
<p><strong>更轻松的维护和扩展</strong></p>
<ul>
<li>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</li>
</ul>
<h2 id="docker-vs-传统虚拟机vmware-virtualbox">Docker VS 传统虚拟机（VMware、VirtualBox）</h2>
<ul>
<li>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。</li>
<li>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</li>
<li>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</li>
</ul>
</li>
</ul>
<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a12da397-d2b3-4414-94ba-01d854ede675/Untitled?AWSAccessKeyId=AKIAJLJXUMP5IHUZAPFQ&Expires=1536379552&Signature=F4EUf6ATfQzeXFcdmZcF5D6TVZ0%3D" />
<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f46f22c7-3246-4b3b-b7f2-529c99b23827/Untitled?AWSAccessKeyId=AKIAJLJXUMP5IHUZAPFQ&Expires=1536379552&Signature=IJ2qgouwxIKzZrvnOc7y1bLBhpw%3D" />
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">容器</th>
<th style="text-align:left">虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">启动时间</td>
<td style="text-align:left">秒级</td>
<td style="text-align:left">分钟级</td>
</tr>
<tr>
<td style="text-align:left">硬盘使用</td>
<td style="text-align:left">一般为 MB</td>
<td style="text-align:left">一般为 GB</td>
</tr>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:left">接近原生</td>
<td style="text-align:left">弱于</td>
</tr>
<tr>
<td style="text-align:left">系统支持量</td>
<td style="text-align:left">单机支持上千个容器</td>
<td style="text-align:left">一般几十个</td>
</tr>
</tbody>
</table>
<h1 id="docker-基本概念">Docker 基本概念</h1>
<h2 id="docker-镜像image">Docker 镜像（Image）</h2>
<ul>
<li>Docker Image 是一个极度精简版的 Linux 程序运行环境</li>
<li>Docker Image 是需要定制化 Build 的一个“安装包”，包括基础镜像+应用的二进制部署包</li>
<li>Docker Image 内不建议有运行期需要修改的配置文件</li>
<li>Dockerfile 用来创建一个自定义的 Image，包含了用户指定的软件依赖等</li>
<li>Docker Image 的最佳实践之一是尽量重用和使用网上公开的基础镜像</li>
</ul>
<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/46acea87-2929-4b6f-975b-492727a4f733/Untitled?AWSAccessKeyId=AKIAJLJXUMP5IHUZAPFQ&Expires=1536379552&Signature=mk%2BIOWz4EM6cLpOa6eoq0LxA1fA%3D" />
<h2 id="docker-容器container">Docker 容器（Container）</h2>
<ul>
<li>Docker Container 是 Image 的实例，共享内核。镜像（ Image ）和容器（ Container ）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li>
<li>Docker Container 的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一 个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</li>
<li>每一个容器运行时，是以镜像为基础层， 在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</li>
<li>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存 于容器存储层的信息都会随容器删除而丢失。</li>
<li>容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</li>
<li>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删 除或者重新运行之后，数据却不会丢失。</li>
<li>Docker Container 里可以运行不同 OS 的 Image，比如 Ubuntu、CentOS</li>
<li>Docker Container 不建议内部开启一个 SSHD 服务，1.3 版本后新增了 docker exec 命令进入容器排查问题。</li>
<li>Docker Container 没有 IP 地址，通常不会有服务端口暴露，是一个封闭的 “盒子/沙箱”</li>
<li>容器的生命周期</li>
</ul>
<img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a4863931-aa9c-4281-a3a5-a9bc773c8491/Untitled?AWSAccessKeyId=AKIAJLJXUMP5IHUZAPFQ&Expires=1536379552&Signature=LvsdRB6qtYolWstrvC364SsqbUk%3D" />
<h2 id="docker-镜像仓库registry">Docker 镜像仓库（Registry）</h2>
<ul>
<li>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用 这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</li>
<li>一个 Docker Registry 中可以包含多个仓库（  Tag ），每个标签对应一个镜像。</li>
<li>一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版 本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给 出标签，将以 latest 作为默认标签。</li>
<li>公共的镜像仓库：
<ul>
<li>时速云 Hub：<a href="https://hub.tenxcloud.com/">https://hub.tenxcloud.com</a></li>
<li>Docker Hub：<a href="https://hub.docker.com/">https://hub.docker.com</a></li>
<li>CoreOS Hub：<a href="https://quay.io/repository/">https://quay.io/repository</a></li>
<li>Google Hub：<a href="https://cloud.google.com/container-registry/">https://cloud.google.com/container-registry</a></li>
</ul>
</li>
<li>私有的镜像仓库，可自行搭建：
<ul>
<li>VMware Harbor：<a href="https://github.com/vmware/harbor">https://github.com/vmware/harbor</a></li>
</ul>
</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://panxiaoan.github.io/tag/docker" class="tag">
                    docker
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://panxiaoan.github.io/post/nginx-xue-xi-bi-ji">
                  <h3 class="post-title">
                    Nginx 学习笔记
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '778be70d2cb3e47d4e2c',
        clientSecret: '4e9b0fe8ee9cff6b19f7d918b334c557b7db01bf',
        repo: 'blog-comments',
        owner: 'panxiaoan',
        admin: ['panxiaoan'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
